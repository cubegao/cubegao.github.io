<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fadaixiaohai</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-07T01:59:57.316Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>fadaixiaohai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Centos7.2上安装编译Swift</title>
    <link href="http://yoursite.com/2018/03/30/installing_and_compiling_swift_on_centos7.2/"/>
    <id>http://yoursite.com/2018/03/30/installing_and_compiling_swift_on_centos7.2/</id>
    <published>2018-03-30T08:10:33.000Z</published>
    <updated>2018-12-07T01:59:57.316Z</updated>
    
    <content type="html"><![CDATA[<p>由于想用Swift写服务玩玩，准备在Centos7.2上部署一个Swift环境，能跑一下Perfect。</p><p>由于Docker的种种好处，当然是选择它来部署Swift环境。</p><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><h4 id="更新yum包到最新。如果是生产机器务必慎重更新内核，避免出现不必要的问题。"><a href="#更新yum包到最新。如果是生产机器务必慎重更新内核，避免出现不必要的问题。" class="headerlink" title="更新yum包到最新。如果是生产机器务必慎重更新内核，避免出现不必要的问题。"></a>更新yum包到最新。<code>如果是生产机器务必慎重更新内核，避免出现不必要的问题。</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@fadaixiaohai ~]<span class="comment"># yum update</span></div></pre></td></tr></table></figure><h4 id="执行-Docker-安装脚本。"><a href="#执行-Docker-安装脚本。" class="headerlink" title="执行 Docker 安装脚本。"></a>执行 Docker 安装脚本。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@fadaixiaohai ~]<span class="comment"># curl -fsSL https://get.docker.com/ | sh</span></div></pre></td></tr></table></figure><h4 id="启动-Docker-进程。"><a href="#启动-Docker-进程。" class="headerlink" title="启动 Docker 进程。"></a>启动 Docker 进程。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@fadaixiaohai ~]<span class="comment"># service docker start</span></div></pre></td></tr></table></figure><h4 id="验证-docker-是否安装成功并在容器中执行一个测试的镜像。"><a href="#验证-docker-是否安装成功并在容器中执行一个测试的镜像。" class="headerlink" title="验证 docker 是否安装成功并在容器中执行一个测试的镜像。"></a>验证 docker 是否安装成功并在容器中执行一个测试的镜像。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@fadaixiaohai ~]<span class="comment"># docker run hello-world</span></div><div class="line">Hello from Docker!</div></pre></td></tr></table></figure><p>大概两三分钟就安装好了，国内的服务器可能要用镜像加速会好点。</p><h3 id="安装Swift"><a href="#安装Swift" class="headerlink" title="安装Swift"></a>安装Swift</h3><h4 id="拉取Swift的镜像到本地。"><a href="#拉取Swift的镜像到本地。" class="headerlink" title="拉取Swift的镜像到本地。"></a>拉取Swift的镜像到本地。</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@fadaixiaohai ~]<span class="comment"># docker pull swift</span></div></pre></td></tr></table></figure><p>镜像拉取成功后就可以使用docker images列出当前我们拉取到本地的所有镜像：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@fadaixiaohai ~]<span class="comment"># docker images</span></div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">swift               latest              934835f58041        3 weeks ago         1.3GB</div><div class="line">hello-world         latest              f2a91732366c        4 months ago        1.85kB</div></pre></td></tr></table></figure></p><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。</p><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。</p><h4 id="在镜像里面创建一个容器并且连接它"><a href="#在镜像里面创建一个容器并且连接它" class="headerlink" title="在镜像里面创建一个容器并且连接它"></a>在镜像里面创建一个容器并且连接它</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@fadaixiaohai ~]<span class="comment"># docker run  -it --name swiftfun swift /bin/bash</span></div></pre></td></tr></table></figure><p>其中<code>-it</code>意思是以交互式(interactive)终端(tty)的方式运行，<code>--name swiftfun</code>指定容器的名称，<code>/bin/bash</code>是容器启动后执行的命令，也就是进入bash控制台，运行成功后会进入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@8408a26c123b:/<span class="comment">#</span></div></pre></td></tr></table></figure></p><p>默认是root用户，这里我们使用诸如<code>apt-get</code>命令时就不需要加sudo了</p><p>现在，你可以在容器中运行<code>swift --version</code>来确认是否配置成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">root@8408a26c123b:/<span class="comment"># swift --version</span></div><div class="line">Swift version 4.0.3 (swift-4.0.3-RELEASE)</div><div class="line">Target: x86_64-unknown-linux-gnu</div></pre></td></tr></table></figure></p><p>然后用<code>swift</code>命令看是否能进入swift REPL：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">root@8408a26c123b:/<span class="comment"># swift</span></div><div class="line">error: failed to launch REPL process: process launch failed: <span class="string">'A'</span> packet returned an error: 8</div></pre></td></tr></table></figure></p><p>发现报错了，找到Docker官方给的解决方案是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@fadaixiaohai ~]<span class="comment"># docker run --cap-add sys_ptrace -it --rm swift swift</span></div><div class="line">error: failed to launch REPL process: process launch failed: <span class="string">'A'</span> packet returned an error: 8</div></pre></td></tr></table></figure></p><p>运行时添加了<code>--cap-add sys_ptrace</code>选项，应该是添加一个系统的权限。加上<code>--rm</code>选项是创建新容器时，把已经存在的旧容器删掉。但是依然是相同的报错。</p><p>最后在github上面好到了解决方案。添加一条<code>--privileged</code>。它的含义是：<br>–privileged=false Give extended privileges to this container 赋予容器扩展权限<br>运行结果如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@fadaixiaohai ~]<span class="comment"># docker run --cap-add sys_ptrace --privileged -it --rm swift swift</span></div><div class="line">Welcome to Swift version 4.0.3 (swift-4.0.3-RELEASE). Type :<span class="built_in">help</span> <span class="keyword">for</span> assistance.</div><div class="line">1&gt; <span class="built_in">print</span>(<span class="string">"hello world"</span>)</div><div class="line">hello world</div><div class="line">2&gt;</div></pre></td></tr></table></figure></p><p>以后想要连接swiftfun这个容器，必须先启动，后连接。方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@fadaixiaohai ~]<span class="comment"># docker start swiftfun</span></div><div class="line">swiftfun</div><div class="line">[root@fadaixiaohai ~]<span class="comment"># docker attach swiftfun</span></div><div class="line">root@8408a26c123b:/<span class="comment">#</span></div></pre></td></tr></table></figure></p><p>查看所有容器状态:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@fadaixiaohai ~]<span class="comment"># docker ps -a</span></div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                          PORTS               NAMES</div><div class="line">8408a26c123b        swift               <span class="string">"/bin/bash"</span>         27 hours ago        Exited (0) About a minute ago                       swiftfun</div><div class="line">cc12559d586c        hello-world         <span class="string">"/hello"</span>            27 hours ago        Exited (0) 27 hours ago                             boring_yonath</div></pre></td></tr></table></figure></p><h3 id="设置Docker开机启动。"><a href="#设置Docker开机启动。" class="headerlink" title="设置Docker开机启动。"></a>设置Docker开机启动。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@fadaixiaohai ~]<span class="comment"># systemctl enable docker</span></div><div class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</div></pre></td></tr></table></figure><p>以上就是本文的所有内容了，祝你玩得愉快！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于想用Swift写服务玩玩，准备在Centos7.2上部署一个Swift环境，能跑一下Perfect。&lt;/p&gt;
&lt;p&gt;由于Docker的种种好处，当然是选择它来部署Swift环境。&lt;/p&gt;
&lt;h3 id=&quot;安装Docker&quot;&gt;&lt;a href=&quot;#安装Docker&quot; cla
      
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
      <category term="Centos" scheme="http://yoursite.com/tags/Centos/"/>
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>容易被人忽略的NSCache</title>
    <link href="http://yoursite.com/2017/01/15/nscache_is_easily_overlooked/"/>
    <id>http://yoursite.com/2017/01/15/nscache_is_easily_overlooked/</id>
    <published>2017-01-15T02:22:24.000Z</published>
    <updated>2018-12-07T01:59:57.316Z</updated>
    
    <content type="html"><![CDATA[<p>第一次见到<code>NSCache</code>，是在<code>SDWebImage</code>中。<code>SDWebImage</code>的内存缓存机制就是通过<code>NSCache</code>实现的。所以可能你不太了解这个类，但是其实一直在使用它。</p><p>###为什么要使用NSCache？<br>我们通常用使用缓存来临时存储短时间使用但创建昂贵的对象。重用这些对象可以优化性能，因为它们的值不需要重新计算。另外一方面，这些对象对于程序来说不是紧要的，在内存紧张时会被丢弃。如果对象被丢弃了，则下次使用时需要重新计算。</p><p><code>NSCache</code>是一个可变的集合，主要用来存储<code>key-value</code>对。它有着和<code>NSMutableDictionary</code>类似的API。实际上，<code>NSCache</code>就像是一个会自动移除对象来释放内存的<code>NSMutableDictionary</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (id)objectForKey:(id)key</div><div class="line">- (void)setObject:(id)obj forKey:(id)key</div><div class="line">- (void)setObject:(id)obj forKey:(id)key cost:(NSUInteger)num</div><div class="line">- (void)removeObjectForKey:(id)key</div><div class="line">- (void)removeAllObjects</div></pre></td></tr></table></figure></p><p><code>NSCahce</code>与可变集合不同之处：</p><blockquote><p>1.<code>NSCache</code>类有自己的自动删除策略，以确保缓存不用使用太多的系统内存。如果其他应用需要内存，则自动删除策略会从缓存中删除一些项目，从而最大限度的减少内存占用。<br> 2.<code>NSCache</code>是线程安全的，我们可以从不同的线程中添加、删除和查询缓存中的对象，而不需要锁定缓存区域。其中线程安全是<code>pthread_mutex</code>完成的。<br>3.明显区别于<code>NSMutableDictionary</code>的是，键对象不会被<code>retain</code>。（键不需要实现<code>NSCopying</code>协议）</p></blockquote><p>###需要注意的点<br><code>NSCache</code>提供了一个<code>delegate</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)cache:(NSCache *)cache willEvictObject:(id)obj</div></pre></td></tr></table></figure></p><p>需要注意的是在这个代理方法中不能修改<code>NSCache</code>对象，也就是只能测试使用。</p><blockquote><p><code>NSCache</code>提供了一系列的属性来限制缓存的大小。比如属性<code>countLimit</code>限定了缓存最多维护的对象的个数，属性<code>totalCostLimit</code>限定了缓存能维持的最大内存。<br>在存取方法中，有一个<code>setObject:forKey:cost:</code>方法，它和<code>setObject:forKey:</code>方法类似，但是带着<code>cost</code>参数。<code>cost</code>表示每次的消耗，如对象占用的字节数。当内存不足或者所有缓存对象的总消耗超过了最大值时，缓存会移除其中的一些对象。</p></blockquote><p>上面这些内容，看起来很美好，但是问题来了。从缓存中移除对象并不能保证顺序，也就是有可能刚写入的对象，就被丢弃了。如果你要使用<code>cost</code>来完成一些特殊的需求，那你可能要失望了。所以计算<code>cost</code>值，可能反而会增加使用缓存的代价。</p><blockquote><p>另外<code>countLimit</code>和<code>totalCostLimit</code>属性都是不精确或者不严格的，也就是如果缓存的数量超过了<code>countLimit</code>，或者缓存维持的最大内存超过了<code>totalCostLimit</code>，缓存中的对象可能会被丢弃，也可能不会，具体的策略只有苹果自己知道。<br>虽然苹果提供了<code>NSDiscardableContent</code>来控制对象是否会被自动移除的机制，但是这可能会让你碰到更多的问题。</p></blockquote><p>###总结<br>虽然<code>NSCache</code>有一些缺点，但是也应该去积极使用。如果我们需要构建内存缓存机制，就应该选用<code>NSCache</code>而非<code>NSDictionary</code>，这样可以减少我们应用对内存的占用，从而达到优化内存的目标。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一次见到&lt;code&gt;NSCache&lt;/code&gt;，是在&lt;code&gt;SDWebImage&lt;/code&gt;中。&lt;code&gt;SDWebImage&lt;/code&gt;的内存缓存机制就是通过&lt;code&gt;NSCache&lt;/code&gt;实现的。所以可能你不太了解这个类，但是其实一直在使用它。&lt;/
      
    
    </summary>
    
    
      <category term="NSCache" scheme="http://yoursite.com/tags/NSCache/"/>
    
  </entry>
  
</feed>
